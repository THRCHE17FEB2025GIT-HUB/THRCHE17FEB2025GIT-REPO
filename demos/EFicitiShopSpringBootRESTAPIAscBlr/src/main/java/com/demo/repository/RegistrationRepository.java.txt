package com.demo.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.demo.entity.Registration;

/**
 * RegistrationRepository is an interface for performing CRUD operations on Registration entities.
 * It extends JpaRepository to provide methods to interact with the database.
 */
@Repository
public interface RegistrationRepository extends JpaRepository<Registration, String> {

    /**
     * Finds a Registration entity by email and password.
     *
     * @param email the email of the registration
     * @param password the password of the registration
     * @return the Registration entity if found, otherwise null
     */
    Registration findByEmailAndPassword(String email, String password);

    /**
     * Finds a Registration entity by email.
     *
     * @param email the email of the registration
     * @return the Registration entity if found, otherwise null
     */
    Registration findByEmail(String email);

    // List 10 interesting custom queries that can be performed on the Registration entity
    // The methods below can be added to the RegistrationRepository interface to perform custom queries on the Registration entity. These methods use Spring Data JPA query creation to generate the queries based on the method names. The queries are automatically generated by Spring Data JPA based on the method names, and no additional query is required to be written. The queries are executed by calling the methods on the RegistrationRepository interface.
    // 1. Find all registrations with a specific role
    // List<Registration> findByRole(String role);
    // 2. Find all registrations with a specific status
    // The query internally created for this method is SELECT * FROM REGISTRATIONS WHERE STATUS = ?1
    // List<Registration> findByStatus(String status);
    // 3. Find all registrations with a specific role and status
    // The query internally created for this method is SELECT * FROM REGISTRATIONS WHERE ROLE = ?1 AND STATUS = ?2
    // The above is a sample query that is internally created by Spring Data JPA based on the method name. The actual query executed by the database may vary based on the database dialect and configuration. The query is not written explicitly in SQL or JPQL, but is generated by Spring Data JPA based on the method name. It is a convenient way to create queries without writing SQL or JPQL. The method name is used to generate the query, and the parameters passed to the method are used as query parameters. The query is executed when the method is called on the repository interface. The result of the query is returned as a List of Registration entities. 
    // Does the above query get executed as a native query or JPQL query?
    // The above query is executed as a JPQL (Java Persistence Query Language) query. Spring Data JPA uses JPQL by default to generate queries based on method names. JPQL is a platform-independent query language that is similar to SQL but is specific to JPA (Java Persistence API). The query is executed by the JPA provider (Hibernate, EclipseLink, etc.) and translated into the appropriate SQL dialect for the underlying database. The query is executed as a JPQL query, not as a native query. The query is written in a format that is specific to JPA and is not tied to a particular database. The query is executed by the JPA provider and translated into SQL for the underlying database. The result of the query is returned as a List of Registration entities.
    
    // List<Registration> findByRoleAndStatus(String role, String status);
    // 4. Find all registrations with a specific role or status
    // List<Registration> findByRoleOrStatus(String role, String status);
    // 5. Find all registrations with a specific role and status in a specific order
    // List<Registration> findByRoleAndStatusOrderByEmailAsc(String role, String status);
    // 6. Find all registrations with a specific role and status in a specific order
    // List<Registration> findByRoleAndStatusOrderByEmailDesc(String role, String status);
    // 7. Find all registrations with a specific role and status in a specific order
    // List<Registration> findByRoleAndStatusOrderByEmailAsc(String role, String status);
    // 8. Find all registrations with a specific role and status in a specific order
    // List<Registration> findByRoleAndStatusOrderByEmailDesc(String role, String status);
    // 9. Find all registrations with a specific role and status in a specific order
    // List<Registration> findByRoleAndStatusOrderByEmailAsc(String role, String status);
    // 10. Find all registrations with a specific role and status in a specific order
    // List<Registration> findByRoleAndStatusOrderByEmailDesc(String role, String status);
    // Distinct registrations with a specific role
    // List<Registration> findDistinctByRole(String role);

    // Example with native query. The native query is written in SQL.
    // @Query(value = "SELECT * FROM REGISTRATIONS WHERE EMAIL = ?1", nativeQuery = true)
    // Registration findByEmail(String email);
    // Alternate to native query. The query is written in JPQL.
    // @Query("SELECT r FROM Registration r WHERE r.email = ?1")
    // Registration findByEmail(String email);
}
// Explain the below query:
// SELECT r FROM Registration r WHERE r.email = ?1
// This query is written in JPQL (Java Persistence Query Language) and it selects a Registration entity (r) where the email attribute of the entity is equal to the first parameter passed to the query. The ?1 is a placeholder for the first parameter in the query. The query is used to find a Registration entity by its email attribute.

//Native query vs JPQL
//Native query is written in SQL and is specific to the underlying database, while JPQL is a platform-independent query language that is similar to SQL but is specific to JPA (Java Persistence API). Native queries are used when you need to write database-specific queries, while JPQL is used for writing queries that are independent of the underlying database.
// Advantages and disadvantages of native query:
// Advantages:
// 1. Allows you to write complex queries that are specific to the underlying database.
// 2. Can be more efficient in some cases as it allows you to take advantage of database-specific features.
// Disadvantages:
// 1. Less portable as the queries are specific to the underlying database.
// 2. May require more maintenance if the underlying database changes.
// Advantages and disadvantages of JPQL:
// Advantages:
// 1. Platform-independent as it is specific to JPA and not tied to a particular database.
// 2. Easier to maintain as the queries are written in a standard format.
// Disadvantages:
// 1. Limited in terms of database-specific features that can be used.
// 2. May not be as efficient as native queries in some cases.
// In general, it is recommended to use JPQL for most queries as it provides a more portable and maintainable solution. Native queries should be used sparingly for cases where complex database-specific queries are required.


// can we use decode function in JPQL?
// No, the decode function is not supported in JPQL. The decode function is specific to SQL and is used to perform conditional logic in SQL queries. In JPQL, you can achieve similar functionality using the CASE expression. The CASE expression allows you to perform conditional logic in JPQL queries by specifying multiple conditions and their corresponding values. Here is an example of how you can use the CASE expression in JPQL:

//decode function in SQL:
// SELECT DECODE(column_name, 'value1', 'result1', 'value2', 'result2', 'default_result') FROM table_name;
// Equivalent CASE expression in JPQL:
// SELECT CASE WHEN column_name = 'value1' THEN 'result1' WHEN column_name = 'value2' THEN 'result2' ELSE 'default_result' END FROM EntityName e;